"use client";

import { db, type Deck, type Card, type ImportDoc, type GeneratedCard, type Review } from "@/lib/db";
import { getSettings, getLearningSteps } from "./settings";

export async function listDecks(): Promise<Deck[]> {
  return await db.decks.orderBy("updatedAt").reverse().toArray();
}

export async function createDeck(
  name: string,
  parentDeckId?: string | null
): Promise<Deck> {
  const now = Date.now();
  const deck: Deck = {
    id: crypto.randomUUID(),
    name,
    createdAt: now,
    updatedAt: now,
    parentDeckId: parentDeckId ?? null,
  };
  await db.decks.add(deck);
  return deck;
}

export async function renameDeck(id: string, name: string): Promise<void> {
  await db.decks.update(id, {
    name,
    updatedAt: Date.now(),
  });
}

export async function deleteDeck(id: string): Promise<void> {
  await db.transaction("rw", db.decks, db.cards, async () => {
    // Cascade delete: get all descendant deck IDs
    const descendantIds = await getDeckAndAllChildren(id);
    
    // Delete all cards from all descendant decks
    for (const deckId of descendantIds) {
      await db.cards.where("deckId").equals(deckId).delete();
    }
    
    // Delete all descendant decks (including the parent)
    for (const deckId of descendantIds) {
      await db.decks.delete(deckId);
    }
  });
}

// Get deck and all its descendant sub-decks (recursive)
export async function getDeckAndAllChildren(deckId: string): Promise<string[]> {
  const result: string[] = [deckId];
  
  async function collectChildren(parentId: string) {
    const children = await db.decks
      .where("parentDeckId")
      .equals(parentId)
      .toArray();
    
    for (const child of children) {
      result.push(child.id);
      await collectChildren(child.id);
    }
  }
  
  await collectChildren(deckId);
  return result;
}

// Get full deck path (e.g., "Vocabulaire > Thème 1")
export async function getDeckPath(deckId: string): Promise<string> {
  const path: string[] = [];
  let currentId: string | null = deckId;
  
  while (currentId) {
    const deck: Deck | undefined = await db.decks.get(currentId);
    if (!deck) break;
    path.unshift(deck.name);
    currentId = deck.parentDeckId ?? null;
  }
  
  return path.join(" > ");
}

// Get all decks with their full paths (for dropdown selection)
export async function listDecksWithPaths(): Promise<Array<{ deck: Deck; path: string }>> {
  const allDecks = await listDecks();
  const decksWithPaths = await Promise.all(
    allDecks.map(async (deck) => ({
      deck,
      path: await getDeckPath(deck.id),
    }))
  );
  // Sort by path for better UX
  return decksWithPaths.sort((a, b) => a.path.localeCompare(b.path));
}

export async function listCards(deckId: string): Promise<Card[]> {
  return await db.cards.where("deckId").equals(deckId).toArray();
}

export async function createCard(
  deckId: string,
  front: string,
  back: string
): Promise<Card> {
  const now = Date.now();
  const card: Card = {
    id: crypto.randomUUID(),
    deckId,
    front,
    back,
    createdAt: now,
    updatedAt: now,
    dueAt: now,
    intervalDays: 0,
    ease: 2.5,
    reps: 0,
    lapses: 0,
    state: "new",
    suspended: false,
  };
  await db.cards.add(card);
  await db.decks.update(deckId, { updatedAt: now });
  return card;
}

export async function deleteCard(id: string): Promise<void> {
  const card = await db.cards.get(id);
  if (card) {
    await db.cards.delete(id);
    await db.decks.update(card.deckId, { updatedAt: Date.now() });
  }
}

export async function updateCard(
  id: string,
  front: string,
  back: string
): Promise<void> {
  const card = await db.cards.get(id);
  if (!card) {
    throw new Error("Card not found");
  }
  await db.cards.update(id, {
    front,
    back,
    updatedAt: Date.now(),
  });
  await db.decks.update(card.deckId, { updatedAt: Date.now() });
}

export async function suspendCard(id: string): Promise<void> {
  await db.cards.update(id, {
    suspended: true,
    updatedAt: Date.now(),
  });
}

export async function unsuspendCard(id: string): Promise<void> {
  await db.cards.update(id, {
    suspended: false,
    updatedAt: Date.now(),
  });
}

export async function moveCardsToDeck(
  cardIds: string[],
  targetDeckId: string
): Promise<void> {
  if (!targetDeckId || targetDeckId === "") {
    throw new Error("Target deck ID is required");
  }

  if (cardIds.length === 0) {
    return; // No-op if no cards to move
  }

  // Check if all cards are already in the target deck
  const cards = await db.cards.where("id").anyOf(cardIds).toArray();
  const allInTarget = cards.every((card) => card.deckId === targetDeckId);
  if (allInTarget) {
    return; // No-op if all cards are already in target deck
  }

  const now = Date.now();

  await db.transaction("rw", db.cards, db.decks, async () => {
    // Update all cards to the target deck
    await db.cards
      .where("id")
      .anyOf(cardIds)
      .modify({ deckId: targetDeckId, updatedAt: now });

    // Update updatedAt for both source and target decks
    const sourceDeckIds = new Set(cards.map((c) => c.deckId));
    for (const sourceDeckId of sourceDeckIds) {
      if (sourceDeckId !== targetDeckId) {
        await db.decks.update(sourceDeckId, { updatedAt: now });
      }
    }
    await db.decks.update(targetDeckId, { updatedAt: now });
  });
}

export async function createImport(
  deckId: string | null,
  filename: string,
  fileType: "pdf" | "image",
  text: string,
  pageCount?: number,
  ocrConfidence?: number
): Promise<ImportDoc> {
  const importDoc: ImportDoc = {
    id: crypto.randomUUID(),
    deckId,
    filename,
    fileType,
    createdAt: Date.now(),
    text: text.length > 50000 ? text.substring(0, 50000) + "...[tronqué]" : text,
    pageCount,
    ocrConfidence,
  };
  await db.imports.add(importDoc);
  return importDoc;
}

export async function listImports(deckId: string | null): Promise<ImportDoc[]> {
  if (deckId === null) {
    return await db.imports.orderBy("createdAt").reverse().toArray();
  }
  const imports = await db.imports.where("deckId").equals(deckId).toArray();
  return imports.sort((a, b) => b.createdAt - a.createdAt);
}

export interface CardProposal {
  front: string;
  back: string;
  confidence?: number;
  tags?: string[];
}

export interface GenerateCardsResult {
  cards: CardProposal[];
  usedFallback: boolean;
}

/**
 * Clean text: remove PDF headers, normalize whitespace, remove short lines
 */
function cleanText(text: string): string {
  // Remove PDF page markers like "--- Page 1 ---" (with variations)
  let cleaned = text.replace(/^---\s*Page\s*\d+\s*---/gim, "");
  cleaned = cleaned.replace(/^---\s*Page\s*\d+\s*---/gm, ""); // Also match without multiline flag
  
  // Split into lines, filter and clean
  const lines = cleaned
    .split(/\n/)
    .map((line) => line.trim())
    .filter((line) => line.length >= 3 && !line.match(/^---/)); // Remove any remaining --- lines
  
  // Join lines into paragraphs, normalize whitespace
  cleaned = lines.join(" ");
  cleaned = cleaned.replace(/\s+/g, " ").trim();
  
  return cleaned;
}

/**
 * Extract year from text (17xx, 18xx, 19xx, 20xx)
 */
function extractYear(text: string): string | null {
  const yearMatch = text.match(/\b(1[7-9]\d{2}|20\d{2})\b/);
  return yearMatch ? yearMatch[1] : null;
}

/**
 * Extract date from text (various formats)
 */
function extractDate(text: string): string | null {
  // Match patterns like "le 14 juillet 1789", "en 1789", "en janvier 1789"
  const datePatterns = [
    /\b(le\s+)?(\d{1,2}\s+[a-zéèê]+(?:\s+\d{4})?)\b/gi,
    /\b(en\s+)(\d{4})\b/gi,
    /\b(en\s+)([a-zéèê]+(?:\s+\d{4})?)\b/gi,
  ];
  
  for (const pattern of datePatterns) {
    const match = text.match(pattern);
    if (match) {
      return match[0].trim();
    }
  }
  
  return null;
}

/**
 * Generate fallback cards locally from text using heuristic Q/A patterns
 */
function generateFallbackCards(text: string, maxCards: number = 15): CardProposal[] {
  // 1) Text cleanup
  const cleanedText = cleanText(text);
  
  // 2) Sentence splitting
  const sentences = cleanedText
    .split(/(?<=[.!?])\s+/)
    .map((s) => s.trim())
    .filter((s) => s.length >= 25 && s.length <= 180);
  
  const cards: CardProposal[] = [];
  const seenFronts = new Set<string>();
  
  for (const sentence of sentences) {
    if (cards.length >= maxCards) break;
    
    let front: string | null = null;
    let back: string | null = null;
    
    // Pattern A: "X est Y" / "X était Y" / "X devient Y" / "X fut Y"
    const patternA = sentence.match(/^([A-ZÉÈÊÀÁÂ][^.!?]{2,50}?)\s+(est|était|devient|fut|sont|étaient|devinrent)\s+(.+?)[.!?]?$/i);
    if (patternA) {
      const [, x, , y] = patternA;
      const xClean = x.trim().replace(/,$/, ""); // Remove trailing comma
      const yClean = y.trim();
      if (xClean.length > 2 && yClean.length > 3) {
        front = `Qu'est-ce que ${xClean} ?`;
        back = yClean;
      }
    }
    
    // Pattern B: "X a lieu le DATE" / "X eut lieu le DATE" / "X se déroule en DATE" / "X débute en DATE"
    if (!front) {
      const patternB = sentence.match(/^([A-ZÉÈÊÀÁÂ][^.!?]{2,50}?)\s+(a\s+lieu|eut\s+lieu|se\s+déroule|débute)\s+(.+?)[.!?]?$/i);
      if (patternB) {
        const [, x, , datePart] = patternB;
        const xClean = x.trim().replace(/,$/, "");
        const date = extractDate(datePart) || datePart.trim();
        if (xClean.length > 2 && date.length > 2) {
          front = `Quand a lieu ${xClean} ?`;
          back = date;
        }
      }
    }
    
    // Pattern C: "En 17xx/18xx/19xx/20xx, EVENT"
    if (!front) {
      const patternC = sentence.match(/^En\s+(\d{4}),\s*(.+?)[.!?]?$/i);
      if (patternC) {
        const [, year, event] = patternC;
        front = `Que se passe-t-il en ${year} ?`;
        back = event.trim();
      }
    }
    
    // Pattern D: "PERSONNE ... en YEAR" (e.g., "Louis XVI ... en 1789")
    if (!front) {
      const year = extractYear(sentence);
      if (year) {
        // Try to find a person name (capitalized word at start, 2-30 chars)
        const personMatch = sentence.match(/^([A-ZÉÈÊÀÁÂ][a-zéèêàáâ]+(?:\s+[A-ZÉÈÊÀÁÂ][a-zéèêàáâ]+){0,2})/);
        if (personMatch) {
          const person = personMatch[1].trim();
          if (person.length >= 3 && person.length <= 30) {
            front = `Quel est le lien entre ${person} et ${year} ?`;
            back = sentence; // Use full sentence as fallback
          }
        }
      }
    }
    
    // Pattern E: Fallback - "Explique : {shortened sentence}"
    if (!front) {
      const shortened = sentence.length > 90 ? sentence.substring(0, 87) + "..." : sentence;
      front = `Explique : ${shortened}`;
      back = sentence;
    }
    
    // De-duplication (case-insensitive)
    const frontLower = front.toLowerCase();
    if (seenFronts.has(frontLower)) {
      continue;
    }
    seenFronts.add(frontLower);
    
    cards.push({
      front: front.trim(),
      back: back?.trim() || sentence,
      confidence: 0.5,
    });
  }
  
  // Quick test logs (optional, for debugging)
  if (process.env.NODE_ENV === "development") {
    console.log(`[Fallback] Generated ${cards.length} cards from ${sentences.length} sentences`);
  }
  
  return cards;
}

export async function generateCards(
  importId: string,
  deckId: string,
  deckName?: string,
  maxCards: number = 20
): Promise<GenerateCardsResult> {
  const importDoc = await db.imports.get(importId);
  if (!importDoc) {
    throw new Error("Import not found");
  }

  try {
    const response = await fetch("/api/generate-cards", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        text: importDoc.text,
        deckName,
        maxCards,
      }),
    });

    // Check for specific error status codes
    if (!response.ok) {
      const status = response.status;
      if (status === 401 || status === 429 || status >= 500) {
        // Use fallback for these errors
        const fallbackCards = generateFallbackCards(importDoc.text, maxCards);
        return { cards: fallbackCards, usedFallback: true };
      }
      
      // For other errors, try to parse error message
      try {
        const error = await response.json();
        throw new Error(error.error || "Failed to generate cards");
      } catch {
        throw new Error(`HTTP ${status}: Failed to generate cards`);
      }
    }

    const data = await response.json();
    return { cards: data.cards || [], usedFallback: false };
  } catch (error) {
    // Network errors or other failures - use fallback
    if (error instanceof TypeError || error instanceof Error) {
      const fallbackCards = generateFallbackCards(importDoc.text, maxCards);
      return { cards: fallbackCards, usedFallback: true };
    }
    throw error;
  }
}

export async function persistGeneratedCards(
  importId: string,
  deckId: string,
  selectedCards: CardProposal[]
): Promise<Card[]> {
  const now = Date.now();
  const cards: Card[] = [];

  await db.transaction("rw", db.cards, db.generatedCards, async () => {
    for (const proposal of selectedCards) {
      const card: Card = {
        id: crypto.randomUUID(),
        deckId,
        front: proposal.front,
        back: proposal.back,
        createdAt: now,
        updatedAt: now,
        dueAt: now,
        intervalDays: 0,
        ease: 2.5,
        reps: 0,
        lapses: 0,
        state: "new",
        suspended: false,
      };
      await db.cards.add(card);
      cards.push(card);

      const generatedCard: GeneratedCard = {
        id: crypto.randomUUID(),
        importId,
        deckId,
        front: proposal.front,
        back: proposal.back,
        createdAt: now,
      };
      await db.generatedCards.add(generatedCard);
    }

    await db.decks.update(deckId, { updatedAt: now });
  });

  return cards;
}

// SRS Functions (Phase 2)

export async function getDueCards(
  deckId: string,
  limit: number = 50
): Promise<Card[]> {
  const now = Date.now();
  // Get all descendant deck IDs (including the deck itself)
  const deckIds = await getDeckAndAllChildren(deckId);
  
  // Get all due cards from all descendant decks (exclude suspended)
  const allCards: Card[] = [];
  for (const id of deckIds) {
    const cards = await db.cards
      .where("deckId")
      .equals(id)
      .filter((card) => card.dueAt <= now && !card.suspended)
      .toArray();
    allCards.push(...cards);
  }
  
  // Sort by dueAt ascending and limit
  return allCards.sort((a, b) => a.dueAt - b.dueAt).slice(0, limit);
}

export async function getDueCount(deckId: string): Promise<number> {
  const now = Date.now();
  // Get all descendant deck IDs (including the deck itself)
  const deckIds = await getDeckAndAllChildren(deckId);
  
  // Count all due cards from all descendant decks (exclude suspended)
  let count = 0;
  for (const id of deckIds) {
    const cards = await db.cards
      .where("deckId")
      .equals(id)
      .filter((card) => card.dueAt <= now && !card.suspended)
      .toArray();
    count += cards.length;
  }
  return count;
}

// Get card counts by state for a deck (including sub-decks)
export async function getDeckCardCounts(deckId: string): Promise<{
  new: number;
  learning: number;
  review: number;
}> {
  const now = Date.now();
  // Get all descendant deck IDs (including the deck itself)
  const deckIds = await getDeckAndAllChildren(deckId);
  
  let newCount = 0;
  let learningCount = 0;
  let reviewCount = 0;
  
  for (const id of deckIds) {
    const cards = await db.cards
      .where("deckId")
      .equals(id)
      .filter((card) => !card.suspended)
      .toArray();
    
    for (const card of cards) {
      if (card.state === "new") {
        newCount++;
      } else if (card.state === "learning" && card.dueAt <= now) {
        learningCount++;
      } else if (card.state === "review" && card.dueAt <= now) {
        reviewCount++;
      }
    }
  }
  
  return { new: newCount, learning: learningCount, review: reviewCount };
}

export async function reviewCard(
  cardId: string,
  rating: "again" | "hard" | "good" | "easy"
): Promise<void> {
  const card = await db.cards.get(cardId);
  if (!card) {
    throw new Error("Card not found");
  }

  // Load settings
  const settings = await getSettings();
  const learningSteps = getLearningSteps(settings.learningMode);

  const now = Date.now();
  let ease = card.ease;
  let intervalDays = card.intervalDays;
  let reps = card.reps;
  let lapses = card.lapses;
  let state: "new" | "learning" | "review" = card.state;
  let dueAt: number;

  // Clamp ease between 1.3 and 3.0
  const clampEase = (e: number) => Math.max(1.3, Math.min(3.0, e));

  if (rating === "again") {
    // Card failed: reset to learning, use againDelayMinutes
    ease = clampEase(ease - 0.2);
    lapses += 1;
    reps = 0;
    state = "learning";
    dueAt = now + settings.againDelayMinutes * 60 * 1000;
    intervalDays = 0;
  } else {
    // Card passed: advance through learning steps or review
    reps += 1;
    
    // Determine next step based on current state and learning steps
    if (card.state === "new" || (card.state === "learning" && intervalDays === 0)) {
      // First time seeing this card or in learning phase
      const currentStepIndex = reps - 1;
      if (currentStepIndex < learningSteps.length) {
        // Still in learning phase
        state = "learning";
        const stepMinutes = learningSteps[currentStepIndex];
        dueAt = now + stepMinutes * 60 * 1000;
        intervalDays = 0;
      } else {
        // Completed learning steps, move to review
        state = "review";
        intervalDays = 1; // Start with 1 day
        dueAt = now + intervalDays * 24 * 60 * 60 * 1000;
      }
    } else {
      // Already in review phase
      state = "review";
      const base = intervalDays <= 0 ? 1 : intervalDays;

      if (rating === "hard") {
        ease = clampEase(ease - 0.05);
        intervalDays = Math.max(1, Math.round(base * 1.2));
      } else if (rating === "good") {
        intervalDays = Math.max(1, Math.round(base * ease));
      } else if (rating === "easy") {
        ease = clampEase(ease + 0.05);
        intervalDays = Math.max(1, Math.round(base * ease * 1.3));
      }

      dueAt = now + intervalDays * 24 * 60 * 60 * 1000;
    }
  }

  await db.transaction("rw", db.cards, db.decks, db.reviews, async () => {
    await db.cards.update(cardId, {
      ease,
      intervalDays,
      reps,
      lapses,
      state,
      dueAt,
      lastReviewedAt: now,
      updatedAt: now,
    });

    // Record review for stats tracking
    const review: Review = {
      id: crypto.randomUUID(),
      cardId,
      deckId: card.deckId,
      rating,
      reviewedAt: now,
    };
    await db.reviews.add(review);

    // Update deck's updatedAt
    await db.decks.update(card.deckId, { updatedAt: now });
  });
}

// Stats functions (Phase 3)
export async function getCardsStudiedToday(): Promise<number> {
  const now = Date.now();
  const todayStart = new Date(now);
  todayStart.setHours(0, 0, 0, 0);
  const todayStartMs = todayStart.getTime();

  return await db.reviews
    .where("reviewedAt")
    .aboveOrEqual(todayStartMs)
    .count();
}

export async function getCurrentStreak(): Promise<number> {
  const now = Date.now();
  let currentDate = new Date(now);
  currentDate.setHours(0, 0, 0, 0);
  
  let streak = 0;
  let dayMs = currentDate.getTime();
  
  while (true) {
    const dayEnd = dayMs + 24 * 60 * 60 * 1000 - 1;
    const count = await db.reviews
      .where("reviewedAt")
      .between(dayMs, dayEnd, true, true)
      .count();
    
    if (count === 0) {
      // If today has no reviews, don't count today in streak
      if (streak === 0) {
        // Check yesterday
        dayMs -= 24 * 60 * 60 * 1000;
        continue;
      }
      break;
    }
    
    streak++;
    dayMs -= 24 * 60 * 60 * 1000;
    
    // Limit streak calculation to last 365 days to avoid infinite loop
    if (streak >= 365) break;
  }
  
  return streak;
}

export async function getTotalReviews(): Promise<number> {
  return await db.reviews.count();
}

